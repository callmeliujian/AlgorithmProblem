package 算法;
import java.util.*;

//假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
//
//        请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
//
//         
//
//        示例 1：
//
//        输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
//        输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
//        解释：
//        编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
//        编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
//        编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
//        编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
//        编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
//        编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
//        因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
//        示例 2：
//
//        输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
//        输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
//
//        来源：力扣（LeetCode）
//        链接：https://leetcode.cn/problems/queue-reconstruction-by-height
//        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


//        看不懂题的看过来……
//        [h,k]，h是身高看得懂。问题是为毛k这个数这么奇怪。是不是！
//        这么说试着理解一下，k代表的是，现在这个队里，自己前面的人里面，h比自己大或与自己相等的人-的个数。
//        好比[7,1]，代表，自己高7，排在自己前面，且比自己高或相等的只有一个人。
//        而[7,0]意思是，排在自己前面的人，没有比自己高的！
//        然后给大家看一下这个输出就明白的。
//
//        输入: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
//        输出:
//        [[7, 0]]
//        [[7, 0], [7, 1]]
//        [[7, 0], [6, 1], [7, 1]]
//        [[5, 0], [7, 0], [6, 1], [7, 1]]
//        [[5, 0], [7, 0], [5, 2], [6, 1], [7, 1]]
//        [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]


public class _406_根据身高重建队列 {
// https://leetcode.cn/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/
//    解题思路
//
//    题目描述：整数对 (h, k) 表示，其中 h 是这个人的身高，k 是排在这个人前面且身高大于或等于 h 的人数。
//
//    渔（套路）：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。
//
//    在本题目中，我首先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。
//
//    作者：LeahChao
//    链接：https://leetcode.cn/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/
//    来源：力扣（LeetCode）
//    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


    // 对于数对排序问题
    // 一般是先按key1正序、key2逆序，或者key1逆序、key2正序的方式，先进行一轮排序，以简化解题过程
    public int[][] reconstructQueue(int[][] people) {
        // 按h倒序，这样每个元素前面元素的个数，正好就是大于它的元素个数
        // 按k正序，这样h相同时，k越大肯定越靠后，因为只有靠后才能保证前面大于等于h的元素更多
        // 按照此顺序排队后，每个位置前面比它高或等高的(>=j)的一定是>=k的，
        // 因为比它高的已经都排到前面，相等也按照个数大小保持到了极致
        Arrays.sort(people, (p1, p2) -> {
            if (p1[0] != p2[0]) { // 先按h倒序
                return p2[0] - p1[0];
            }

            return p1[1] - p2[1]; // 再按k正序
        });

        int len = people.length;
        List<int[]> ans = new ArrayList<>(len);

        // 迭代每个元素放入结果队列
        // 后面插入的每个人，不管插入什么位置，都是不会影响前面的k值的
        // 除非相同h，k大的插入到k小的前面，当然这是不可能的(k大的怎么会前面人比k小的还少呢？)
        for (int i = 0; i < len; i++) {
            int[] pi = people[i];
            // 插入后应该保证队列已有个数中，截取pi[1]个
            // 即插入位置坐标为pi[1]，前面有[0, pi[1] - 1]共i个
            ans.add(pi[1], pi);
        }

        return ans.toArray(new int[len][]);
    }

}
